复合选择器：

1.后代选择器：
父子元素之间用空格隔开，只会改变li的样式，不会改变父元素
父元素也可以用id或者class
ul li {
  color: pink;
}

2. 子元素选择器
只选亲儿子
.nav>a {
  color: pink;
}

<div class="nav">
  <a>bbb</a>
</div>

3. 并集选择器



单行文字水平垂直居中：text-align: center;height: 20px;line-height: 20px


元素的显示模式：

1. 块元素
自己独占一行
可以设置宽度和高度
宽度默认是容器（父级宽度）的宽度100%
例：
div
h1-h6 p ul ol li 一般这些块元素内不放块元素

2. 行内元素
只能放文本或其他行内元素
一行内显示，一行可以放多个行内元素
没有宽高，宽度就是本身内容的宽度

例：
a 可以放块元素，不能再放a标签
string b em i del s ins u span

3. 行内块元素
input img td 等，同时具备行内元素和块元素的特点


显示转换元素显示模式
display: block 转换行内元素为块元素
display: inline 转换块元素为行内元素
display: inline-block 转换为行内块元素



css三大特性：

1. 层叠性：当样式冲突时会发生覆盖，遵循就近原则，离得最近的样式起作用

2. 继承性: 子元素会自动继承父元素的某些与文字相关的样式，如（text-, font-, line-, color）

3. 优先级
     !important > 行内样式style="xxx" >    id   >  class 伪class   >    元素      >    继承 或 *
权重：  无穷             1000             0100          0010             0001           0000

复合选择器会涉及权重叠加，但权重叠加不会涉及进位问题



网页布局三大核心：盒子模型，浮动，定位

盒子：-> 当盒子设置了固定的宽度和高度之后，修改border和padding都会改变盒子的大小
边框简写格式：
border: 1px solid pink;  1像素实线粉红色边框
也可以单独设置某一条边线：
border-top: 1px solid blue;
border-collapse: collapse;  合并相邻盒子的边框，解决盒子边框重叠之后加粗的效果


内边距：
padding: 5px 上下左右都是5像素内边距
padding: 5px 10px 上下5  左右10
padding: 5px 10px 20px  上5 左右10 下 20
padding: 5px 10px 20px 30px 上5 右10 下20 左30


外边距：控制盒子与盒子之间的距离

块级盒子水平居中的条件：
1. 盒子必须设置width宽度
2. 盒子左右的外边距都设置为auto，margin: 0px, auto; 上下是0，左右是auto

行内元素和行内块元素水平居中：
1. 父元素设置text-align: center


嵌套块元素塌陷问题：-> 对两个嵌套关系(父子关系)的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷->(父子中)较大的外边距的值。
1. 可以为父元素定义上边框
2. 可以为父元素定义上内边框
3. 可以为父元素添加overflow:hidden


清理元素默认外边距：
* {
  margin: 0
  padding: 0
}

为了兼容性，行内元素只设置左右外边距，不要设置上下。



浮动float：-> 当多个块元素需要水平排列时，使用浮动 -> 在需要浮动的元素上设置浮动，不是在父元素上设置
属性为：none, left, right -> 用于创建浮动框，将其移动到一边，知道左边缘或右边缘触及包含块或另一个浮动框的边缘
浮动的特性：
1. 浮动的元素会脱离标准流
2. 浮动的盒子不再保留原来的位置
3. 元素添加浮动之后都会具有行内块元素的特性

注意事项：
1. 浮动和标准流的父盒子搭配
2. 一个元素浮动了，理论上其兄弟元素一起浮动
3. 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流

清除浮动：-> 由于父级盒子很多情况下不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。
1. 额外标签法
2. 父级元素添加overflow: hidden; 随便写一个overflow值都行 --> 缺点：无法显示溢出的部分
3. 父元素添加:after 伪元素 -->大厂都用
4. 父元素添加双伪元素


定位：
定位 = 定位模式 + 边偏移
定位模式：
1. static 静态定位 -> 就是标准流 ->相当于没有定位
2. relative 相对定位 -> 通过边偏移，总是相对于自己原来的位置开始偏移，同时会保留原来的位置
3. absolute 绝对定位 -> 绝对定位是元素在移动位置的时候，是相对于它的祖先元素来说的。
	                     (1)如果没有祖先元素或者祖先元素没有定位(没有设置position)，则以浏览器为准定位（Document）
						 (2)哪个祖先元素有定位(有设置position），就以那个祖先元素为准
						 (3)绝对定位不占用原先的位置 -> "比float飘得更高"
4. fixed 固定定位 -> 以浏览器的可视窗口作为参照点移动元素
                     (1) 跟父元素没有关系
					 (2) 不随滚动条滚动
					 (3) 固定定位不再占用原先的位置，可以看做是一个特殊的绝对定位

边偏移：
top
buttom
left
right

叠放次序：
z-index -> 数值（没有单位，定位的元素才能使用叠放）可以是正整数，负整数或0，默认是auto，数值越大，盒子越靠上
           如果属性值相同，则按照书写顺序，后来居上

加了定位的行内元素可以设置宽高


浮动的元素不会压住下面标准流的文字 -> 因为浮动的初衷就是做文字环绕效果
绝对定位和固定定位会压住下面标准流的所有内容（包含文字）



显示与隐藏：
display: none  隐藏元素，不再占用原来的位置
display: block 显示元素

visibility: hidden  隐藏元素，保留原来的位置

overflow: visiable 对溢出内容不做处理，内容可能会超出容器
overflow: hidden 隐藏溢出容器的内容，并且不出现滚动条
overflow: scroll： 隐藏溢出容器的内容，溢出的内容将以卷动滚动条的方式呈现。
overflow: auto： 当内容没有溢出容器时不出现滚动条，当内容溢出容器时出现滚动条，按需出现滚动条。此为body对象和textarea的默认值


flex弹性布局: -> 主要用于移动端
flex-direction：设置主轴的方向
justify-content：设置主轴上的子元素排列方式
		flex-start 靠起始位置
		flex-end 靠结束为止
		center 居中
		space-around 每个盒子平均分配剩余空间
		space-between 两边没有空白，平分中间的剩余空间
flex-wrap：设置子元素是否换行
align-content：设置侧轴上的子元素的排列方式（多行）
align-items：设置侧轴上的子元素排列方式（单行）
       strength 会沿着侧轴拉长盒子（盒子不能设置高度（宽度）根据侧轴方向确定）
flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap
